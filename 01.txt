multithreaded!

#include <pthread.h>

#include "thread-safe-linked-list.h"

In this version, the multi-threads technology is used under the X86 architecture. 

pthread_t thread_pool[WORK_THREAD_NUM];

     gcc ParallelGrep.c -o pgrep -lpthread

We use N threads to grep a big file stimultanously based domain	decomposition method. The big file will be divided into N sub domains and then each thread is going to search PATTERN in one area. All threads exit when finished searching.

 - For parallel grep multiple threads can scan a part with SIZE/N characters.

    size_t read;

    Suppose we have 4 threads

        Thread :     0               1               2             3

#include <sys/types.h>                  /* For opendir(), readdir(), closedir()   */

When grepping directories recursively, there are many files to deal with.Thus, it is far away from efficiency to create and destroy threads frequently for each file. Instead of domain decomposition is excluded, we maintain a thread pool and let each thread retrieving file from free task list. Therefore, many files will be addressed in the same time by different threads. So, it is called "Coarse Parallel". Finally, when free list is empty as well as all threads finish the thread pool is destroyed.

Such as, the main thread will add the new file into to Tail while each thread gets task from the Head.

#include <pthread.h>                    /* For pthread_ functions           */ 

	Main thread add and work thread retrieve:

        Suppose we have 2 work threads.

                    Thread1    Thread2     Head                                         Tail

    while ((read = getline(&buf, &buf_size, file)) != -1) {

        /* num bytes read + size of file name + 3 bytes for colons, line

       | Dir Size (MB)   |   standard grep  |  2 threads  | 4 threads  |  8 threads  |

        if ((line = calloc(1, read + strlen(file_display_name) + 3 + 1 + 1)) == NULL) {

pthread_t workThread[THREADSNUM];

pthread_t workThreadPool[THREADSNUM];

static pthread_mutex_t  workThreadPoolMux               = PTHREAD_MUTEX_INITIALIZER;

//static pthread_cond_t   workThreadPoolCond              = PTHREAD_COND_INITIALIZER; 

 *Note: One reason to limit the performance for current parallel program is that the sequential algorithm is more slower than stardard grep. So that we can't get expected speedup even there is little dependence between each threads.*

          include a readable copy of the attribution notices contained

 * NOT in order for output: since each thread prints out the results seperately, the matched line will be mixed.

* Improve method reading IO

* Adjust the number of work threads automatically

    where all tasks have been removed, but a thread is still parsing

void *file_reader(void *arg) {

    if (pthread_detach(pthread_self()) != 0) {

        perror("thread detach error");

            printf("Thread exiting\n");

            pthread_exit(NULL);

void init_thread_pool() {

        if ((err = pthread_create(&thread_pool[i], NULL, file_reader, NULL)) != 0) {

            perror("pthread_create error");

    init_thread_pool();

 * function    : workThreadPoolFun

 * description : The work thread from thread pool. 

workThreadPoolFun(void *arg)

        pthread_mutex_lock(&workThreadPoolMux);

		    // TODO: Awake by a signal from main thread to avoid "while" loop 

        //pthread_cond_wait(&workThreadPoolCond, &workThreadPoolMux);

            pthread_mutex_unlock(&workThreadPoolMux);

                pthread_mutex_unlock(&workThreadPoolMux);

                pthread_exit(NULL);

            pthread_mutex_unlock(&workThreadPoolMux);

 * function    : initThreadPool

 * description : create THREADSNUM threads to work later.

 * return      : return number of available threads.

initThreadPool() 

    // create threads pool

        error = pthread_create(&workThreadPool[i], NULL, workThreadPoolFun, NULL);

 * function    : joinThreadPool

 * description : wait all threads finish.

joinThreadPool() 

    // wait working thread to join

        pthread_join(workTh